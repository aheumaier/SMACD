using SMACD.Shared.Data;
using System.IO;
using System.Threading.Tasks;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace SMACD.Shared.Plugins
{
    /// <summary>
    /// Represents the output of a Plugin that understands how to process artifacts of that Plugin
    /// </summary>
    public abstract class PluginResult
    {
        private const string POINTER_FILE = ".ptr";

        /// <summary>
        /// Pointer that generated this PluginResult
        /// </summary>
        public PluginPointerModel PluginPointer { get; set; }

        /// <summary>
        /// Directory holding artifacts generated by this Plugin
        /// </summary>
        protected string WorkingDirectory { get; private set; }

        public PluginResult()
        {
        }

        public PluginResult(string workingDirectory)
        {
            WorkingDirectory = workingDirectory;
            if (File.Exists(Path.Combine(WorkingDirectory, ".ptr")))
                PluginPointer = LoadResultArtifact<PluginPointerModel>(Path.Combine(WorkingDirectory, POINTER_FILE));
        }

        public PluginResult(PluginPointerModel pluginPointer, string workingDirectory)
        {
            PluginPointer = pluginPointer;
            WorkingDirectory = workingDirectory;

            SaveResultArtifact(Path.Combine(WorkingDirectory, POINTER_FILE), pluginPointer);
        }

        /// <summary>
        /// Execute any tasks that only need to run once during a summary operation
        /// </summary>
        /// <param name="summary">Summary document</param>
        /// <returns></returns>
        public virtual async Task SummaryRunOnce(VulnerabilitySummary summary) => await Task.Yield();

        /// <summary>
        /// Execute any tasks that run generationally; that is, until all tasks report making no changes to the summary that generation
        /// </summary>
        /// <param name="summary">Summary document</param>
        /// <returns><c>TRUE</c> if changes were made, otherwise <c>FALSE</c></returns>
        public virtual async Task<bool> SummaryRunGenerationally(VulnerabilitySummary summary) => await Task.FromResult(false);

        /// <summary>
        /// Serialize an arbitrary object and save it
        /// </summary>
        /// <param name="fileName">File name (no path)</param>
        /// <param name="obj">Object to save</param>
        protected void SaveResultArtifact<T>(string fileName, T obj)
        {
            using (var sw = new StreamWriter(Path.Combine(WorkingDirectory, fileName)))
            {
                var str = new SerializerBuilder()
                    .WithNamingConvention(new CamelCaseNamingConvention())
                    .Build()
                    .Serialize(obj);
                sw.WriteLine(str);
            }
        }

        /// <summary>
        /// Load a serialized object
        /// </summary>
        /// <param name="fileName">File name (no path)</param>
        protected T LoadResultArtifact<T>(string fileName)
        {
            if (!File.Exists(Path.Combine(WorkingDirectory, fileName)))
                return default(T);
            using (var sr = new StreamReader(Path.Combine(WorkingDirectory, fileName)))
            {
                return new DeserializerBuilder()
                    .WithNamingConvention(new CamelCaseNamingConvention())
                    .Build()
                    .Deserialize<T>(sr);
            }
        }
    }
}